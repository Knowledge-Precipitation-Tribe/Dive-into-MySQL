# 悲观锁与乐观锁

## 悲观锁

正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

对于悲观锁来说，当一条线程抢占了资源后，其他的线程将得不到资源，那么这个时候，CPU 就会将这些得不到资源的线程挂起，挂起的线程也会消耗 CPU 的资源，尤其是在高并发的请求中，如图 1 所示。

![&#x56FE;1 &#x9AD8;&#x5E76;&#x53D1;&#x62A2;&#x5360;&#x8D44;&#x6E90;](http://c.biancheng.net/uploads/allimg/190729/5-1ZH916424N14.png)

只能有一个事务占据资源，其他事务被挂起等待持有资源的事务提交并释放资源。当图中的线程 1 提交了事务，那么红包资源就会被释放出来，此时就进入了线程 2，线程 3……线程 n，开始抢夺资源的步骤了，这里假设线程 3 抢到资源，如图2所示。

![&#x56FE;2 &#x591A;&#x7EBF;&#x7A0B;&#x7ADE;&#x4E89;&#x8D44;&#x6E90;&#x548C;&#x6062;&#x590D;](http://c.biancheng.net/uploads/allimg/190729/5-1ZH9164519345.png)

一旦线程 1 提交了事务，那么锁就会被释放，这个时候被挂起的线程就会开始竞争红包资源，那么竞争到的线程就会被 CPU 恢复到运行状态，继续运行。  
  
于是频繁挂起，等待持有锁线程释放资源，一旦释放资源后，就开始抢夺，恢复线程，周而复始直至所有红包资源抢完。试想在高并发的过程中，使用悲观锁就会造成大量的线程被挂起和恢复，这将十分消耗资源，这就是为什么使用悲观锁性能不佳的原因。  
  
有些时候，我们也会把悲观锁称为独占锁，毕竟只有一个线程可以独占这个资源，或者称为阻塞锁，因为它会造成其他线程的阻塞。无论如何它都会造成并发能力的下降，从而导致 CPU 频繁切换线程上下文，造成性能低下。  
  
为了克服这个问题，提高并发的能力，避免大量线程因为阻塞导致 CPU 进行大量的上下文切换，程序设计大师们提出了乐观锁机制，乐观锁已经在企业中被大量应用了。

### 共享锁

共享锁是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改，直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。

### 排他锁

若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。

## 乐观锁

相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。

而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是**基于数据版本（ Version ）记录机制实现**。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

乐观锁是一种不会阻塞其他线程并发的机制，它不会使用数据库的锁进行实现，它的设计里面由于不阻塞其他线程，所以并不会引发线程频繁挂起和恢复，这样便能够提高并发能力，所以也有人把它称为非阻塞锁，那么它的机制是怎么样的呢？  
  
乐观锁使用的是 CAS 原理，所以我们先来讨论 CAS 原理的内容。

### CAS 原理概述

在 CAS 原理中，对于多个线程共同的资源，先保存一个旧值（Old Value），比如进入线程后，查询当前存量为 100 个红包，那么先把旧值保存为 100，然后经过一定的逻辑处理。  
  
当需要扣减红包的时候，先比较数据库当前的值和旧值是否一致，如果一致则进行扣减红包的操作，否则就认为它已经被其他线程修改过了，不再进行操作，CAS 原理流程如图3所示。

![&#x56FE;3 CAS&#x539F;&#x7406;](http://c.biancheng.net/uploads/allimg/190730/5-1ZI013030WQ.png)

CAS 原理并不排斥并发，也不独占资源，只是在线程开始阶段就读入线程共享数据，保存为旧值。当处理完逻辑，需要更新数据的时候，会进行一次比较，即比较各个线程当前共享的数据是否和旧值保持一致。  
  
如果一致，就开始更新数据；如果不一致，则认为该数据已经被其他线程修改了，那么就不再更新数据，可以考虑重试或者放弃。有时候可以重试，这样就是一个可重入锁，但是 CAS 原理会有一个问题，那就是 ABA 问题，下面先来讨论一下 ABA 问题。

### ABA 问题

对于乐观锁而言，我们之前讨论了存在 ABA 的问题，那么什么是 ABA 问题呢？下面看看表 1 的两个线程发生的场景。

| 时刻 | 线程1 | 线程2 | 备注 |
| :--- | :--- | :--- | :--- |
| T0 | —— | —— | 初始化 X=A |
| T1 | 读入X=A | —— | —— |
| T2 | —— | 读入X=A | —— |
| T3 | 处理线程 1 的业务逻辑 | X=B | 修改共享变量为 B |
| T4 | 处理线程 2 业务逻辑第一段 | 此时线程1在 X=B 的情况下运行逻辑 |  |
| T5 | X=A | 还原变量为 A |  |
| T6 | 因为判断 X=A，所以更新数据 | 处理线程 2 业务逻辑第二段 | 此时线程 1 无法知道线程 2 是否修改过 X，引发业务逻辑错误 |
| T7 | —— | 更新数据 | —— |

在 T3 时刻，由于线程 2 修改了 X=B，此时线程 1 的业务逻辑依旧执行，但是到了 T5 时刻，线程 2 又把 X 还原为 A，那么到了 T6 时刻，使用 CAS 原理的旧值判断，线程 1 就会认为 X 值没有被修改过，于是执行了更新。  
  
我们难以判定的是在 T4 时刻，线程 1 在 X=B 的时候，对于线程 1 的业务逻辑是否正确的问题。由于 X 在线程 2 中的值改变的过程为 A-&gt;B-&gt;A，才引发这样的问题，因此人们形象地把这类问题称为 ABA 问题。  
  
ABA 问题的发生，是因为业务逻辑存在回退的可能性。如果加入一个非业务逻辑的属性，比如在一个数据中加入版本号（version），对于版本号有一个约定，就是只要修改 X 变量的数据，强制版本号（version）只能递增，而不会回退，即使是其他业务数据回退，它也会递增，那么 ABA 问题就解决了，如表 2 所示。

|  时刻 | 线程1 | 线程2 | 备注 |
| :--- | :--- | :--- | :--- |
| T0 | —— | —— | 初始化 X=A，version=0 |
| T1 | 读入X=A | —— | 线程1旧值：version=0 |
| T2 | —— | 读入X=A | 线程2旧值：version=0 |
| T3 | 处理线程1的业务逻辑 | X=B | 修改共享变量为 B，version=1 |
| T4 | 处理线程 2 业务逻辑第一段 | —— |  |
| T5 | —— | X=A | 还原变量为A，version=2 |
| T6 | 判断 version == 0，由于线程 2 两次更新数据，导致数据 version=2，所以不再更新数据  | 处理线程 2 业务逻辑第二段 | 此时线程 1 知道旧值 version 和当前 version 不一致，将不更新数据 |
| T7 | —— | 更新数据 | —— |

只是这个 version 变量并不存在什么业务逻辑，只是为了记录更新次数，只能递增，帮助我们克服 ABA 问题罢了，有了这些理论，我们就可以开始使用乐观锁来完成抢红包业务了。

