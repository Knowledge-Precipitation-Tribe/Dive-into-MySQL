# 死锁

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。

## 解决办法

### 一次封锁法

 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。 此方法存在的问题：

（一）一次将以后要用到的全部数据加锁，加大封锁范围，降低系统的并发度。

（二）数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象，所以很难事先精确确定每个事务要封锁的数据对象，为此只能扩大封锁范围，将事务在执行过程中可能要封锁的数据对象全部加锁，这就更降低了并发度。

### 顺序封锁法

 预先对数据对象规定一个封锁熟悉怒，所有事务都按这个顺序实行封锁。如：在B树结构的索引中，规定封锁的顺序必须从根结点开始，然后是下一级的子女结点，逐级封锁。 此方法存在的问题：

（一）数据库系统中封锁的数据对象极多，随着数据的插入、删除等操作而不断变化，要维护这样的资源的封锁顺序很难，成本高。

（二）事务的封锁请求可随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此很难按规定的顺序去加锁。比如：规定数据对象的封锁顺序：A、B、C、D、E。事务T3起初要求封锁数据对象B、C、E，但当它封锁了B、C后，才发现需要封锁A。

以上就是策略就是操作系统中广为采用的预防死锁的策略，但并不适合数据库。所以数据库系统一般采用诊断并解除死锁的方法。

## **死锁的诊断与解除**

数据库系统中诊断死锁的方法与操作系统类似，一般是用超时法或事务等待图法。

### 超时法

指的是如果一个事务的等待时间超过了规定的时限，就认为发送死锁。 

不足：

（一）有可能误判死锁，事务因为其他原因使等待时机超过时限。

（二）时限若设置得太长，死锁发生后不能及时发现。

### 等待图法

指的是用事务等待图动态反应所有事务的等待情况。 事务等待图是一个有向图G=\(T,U\)，其中T为结点的集合，每个结点表示正在运行的事务。U为边的集合，每条边表示事务等待的情况。若T1等待T2，则T1、T2之间划一条有向边，从T1指向T2。事务等待图动态地反映了所有事务的等待情况。并发控制子系统周期性地检测事务等待图，如果发现图中存在回路，则表示系统中出现了死锁。 以上就是死锁的诊断与解除了。

而且DBMS并发控制子系统一旦检测到系统中存在死锁，就会设法解除。通常是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其他事务能继续运行下去。（而且要对撤销的事务所执行的数据修改操作进行恢复）**。**

### **InnoDB处理方法**

InnoDB处理死锁的方式是将持有最少行级排它锁的事务进行回滚。

